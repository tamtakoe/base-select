// Generated by dts-bundle v0.7.3

export abstract class SelectDom {
    paramsDefault: any;
    params: any;
    selectedItems: any[];
    elem: any;
    tmpl: any;
    isOpen: boolean;
    isFocused: boolean;
    isLoading: boolean;
    isRemovable: boolean;
    isEmpty: boolean;
    isDisabled: boolean;
    isReadonly: boolean;
    isDropdownAbove: boolean;
    activeListElement: HTMLElement;
    activeSelectedElement: HTMLElement;
    unbindFocusBlur: (item?: any) => void;
    focusBlurInstance: any;
    abstract searchChange(value: any): void;
    abstract searchKeydown(e: Event): void;
    abstract selectedItemClick(element: HTMLElement, isRemoveButton?: boolean): void;
    abstract listItemClick(element: HTMLElement): void;
    abstract inputFieldClick(): void;
    constructor(element: Element, style?: string | boolean);
    bindInput(inputElement?: any): void;
    addListeners(): void;
    removeListeners(): void;
    blinkRestriction(): void;
    setDropdownAbove(isDropdownAbove: boolean): void;
    setFocus(isFocus: boolean): void;
    setLoading(isLoading: boolean): void;
    setElementLoading(element: Element, isLoading?: boolean): void;
    setRemovable(isRemovable: boolean): void;
    setElementDisabled(element: Element, isDisabled: boolean): void;
    isElementDisabled(element: Element): boolean;
    setDisabled(isDisabled: boolean): void;
    setReadonly(isReadonly: boolean): void;
    openList(): void;
    closeList(): void;
    updatePlaceholder(): void;
    setPlaceholder(text?: string): void;
    setInputInfo(text?: string): void;
    updateInputInfo(): void;
    setDropdownLabel(tmpl?: string): void;
    setEmpty(isEmpty: boolean): void;
    setQuery(text?: string, selectAll?: boolean): void;
    getQuery(): any;
    isListElementSelected(element: Element): boolean;
    setListElementSelected(element: Element): boolean;
    unsetListElementSelected(element: Element): boolean;
    focus(): void;
    blur(): void;
    setMultiple(isMultiple: boolean): void;
    getSelectedItemElementByItem(item: any): HTMLElement;
    getListElementByItem(item: any): any;
    updateLabel(element: HTMLElement, labelGetter: Function, item: any, query?: string, extraLabelElement?: HTMLElement | string): HTMLElement;
    createListItemsGroupElement(groupName: string): any;
    createListItemElement(item: any): any;
    createSelectedItemElement(item: any): any;
    postRenderSelectedElements(): void;
    insertSelectedElements(items?: any[]): void;
    insertSelectedElement(item: any): void;
    removeElement(element: any): void;
    insertListItems(items?: any[], query?: string): any[];
    insertCustomArea(): void;
    setActiveSelectedElement(element?: HTMLElement): void;
    setActiveListElement(element?: HTMLElement): void;
    setFirstActiveListElement(): void;
    setNextActiveListElement(isPrevious?: boolean, parentNode?: HTMLElement): void;
    setPreviousActiveListElement(): void;
    getSiblingElement(element: HTMLElement, isPrevious?: boolean): HTMLElement;
    getFirstListElement(): HTMLElement;
    getLastListElement(): HTMLElement;
    findFirstChildElementWithData(containerElement: HTMLElement, invert?: boolean): HTMLElement;
    findLastChildElementWithData(containerElement: HTMLElement): HTMLElement;
    isDataElement(element: HTMLElement): boolean;
    searchFocusHandler: () => void;
    searchBlurHandler: () => void;
    searchInputHandler: (e: Event) => void;
    searchKeydownHandler: (e: Event) => void;
    searchContainerClickHandler: (e: Event) => void;
    listItemClickHandler: (e: Event) => void;
    listItemMousemoveHandler: (e: Event) => void;
    stopImmediatePropagation: (e: Event) => void;
}

/**
  * Array Diff
  *
  * Based on https://github.com/google/diff-match-patch
  *
  * This library implements Myer's diff algorithm which is generally considered to be the best general-purpose diff.
  * A layer of pre-diff speedups and post-diff cleanups surround the diff algorithm, improving both performance and output quality.
  */
export const myer: any;

export class Select extends SelectDom {
    value: any;
    loadItemsPromise: Promise<any>;
    constructor(element: HTMLElement, params?: any);
    setParams(params?: any, emitEvent?: boolean): void;
    open(): void;
    close(): void;
    loadListItems(query?: any): Promise<any>;
    updateDropdownListItems(query?: string): Promise<void>;
    saveOn(key: string): void;
    updateValue(): void;
    dispatchValue(): void;
    selectItems(items: any[]): Promise<void>;
    selectItem(listItemElement: HTMLElement, isNewItem?: boolean): void;
    deselectItem(selectedElement: HTMLElement, isRemoveButton?: boolean): void;
    deselectAllItems(): void;
    updateSelectedElementList(items?: any[]): void;
    addToSelectedElementList(item: any): void;
    removeSelectedItem(selectedElement: HTMLElement): void;
    selectedItemClick(selectedItemElement: HTMLElement, isRemoveButton?: boolean): void;
    listItemClick(listItemElement: HTMLElement): void;
    inputFieldClick(): void;
    searchChange(value: any): void;
    searchKeydown(e: KeyboardEvent): void;
    dispatchCustomInputEvent(eventName: string, element?: HTMLElement, item?: any, isRemoveButton?: boolean): void;
}
export class SelectWeb extends Select {
    constructor(element: HTMLElement, params?: any);
}

/**
    * Merge object by another one. Use default value if new value is undefined or null
    * @param obj
    * @param newObj
    * @param defaults
    * @returns {any}
    */
export function mergeWithDefaults(obj: any, newObj?: any, defaults?: any): any;
/**
    * Return DOM element which is/into container and contains defined class
    *
    * @param {HTMLElement} element
    * @param {HTMLElement} containerElement
    * @param {string} className
    * @returns {HTMLElement}
    */
export function getElementContainer(element: HTMLElement, containerElement?: HTMLElement, className?: string): HTMLElement;
/**
    * Simulate focus/blur events of the inner input element to the outer element
    *
    * @param {HTMLElement} element
    * @param {HTMLElement} inputElement
    * @param {HTMLElement} isolatedClass for area which is independent on click event
    * @returns {function} unbind function for listeners.
    */
export function bindFocusBlur(element: HTMLElement, inputElement: HTMLElement, isolatedClass?: string): {
        element: HTMLElement;
        inputElement: HTMLElement;
        unbind: () => void;
};
/**
    * Sets the selected item in the dropdown menu
    * of available loadedListItems.
    *
    * @param {object} list
    * @param {object} item
    */
export function scrollActiveOption(list: any, item: any): void;
/**
    * Calculate free space for menu and return true if need to change menu direction
    * @param toggleElement
    * @param menuElement
    * @param defaultMenuHeightPx
    * @returns {boolean}
    */
export function hasNoSpaceBelowForMenu(toggleElement: HTMLElement, menuElement: HTMLElement, defaultMenuHeightPx?: number): boolean;
export function groupsIsEmpty(groups: any): boolean;
/**
    * Find array intersections
    * Equal of lodash _.intersection + getter + invert
    *
    * @param {any[]} xArr
    * @param {any[]} yArr
    * @param {Function} getter
    * @param {boolean} invert
    * @returns {any[]}
    */
export function intersection(xArr: any[], yArr: any[], getter?: Function, invert?: boolean): any[];
/**
    * Filter items by comparison label (=getLabel(item)) and query
    * asc sorting of result
    *
    * @param items
    * @param query
    * @param {Function} getLabel
    * @param {{fields?: any[]; sort?: ("asc" | "desc"); strict?: boolean}} options
    * @returns {any[]}
    */
export function ascSort(items: any, query: any, getLabel: Function, options?: {
        fields?: any[];
        sort?: 'asc' | 'desc';
        strict?: boolean;
}): any[];
/**
    * Transform flat loadedListItems array to groupped object
    *
    * Example:
    * const loadedListItems = [{t: 'A', g: 'x'}, {t: 'B', g: 'x'}, {t: 'C'}]
    * const getter = (option) => option.g
    *
    * groupOptions(loadedListItems, getter)
    * // Result: {'x': [{t: 'A', g: 'x'}, {t: 'B', g: 'x'}], '': [{t: 'C'}]}
    *
    * @param {Array} options
    * @param {(option) => string} groupNameGetter
    * @returns {{: Array}}
    */
export function distributeOptionsByGroup(options?: any[], groupNameGetter?: (item: any) => string): any;
export function findIndex(items: any[], item: any, trackByGetter?: (item: any) => any): number;
export function removeChildren(element: HTMLElement): void;
/**
    *
    * @param {HTMLElement} containerElement
    * @param {any[]} newItems
    * @param {(item) => HTMLElement} elementConstructor
    * @param {Function} trackFieldGetter
    * @param {boolean} appendUndefinedItems - place undefined items to the end of list (they prepend by default)
    * @returns {HTMLElement} containerElement with changes
    */
export function updateElements(containerElement: HTMLElement, newItems: any[], elementConstructor: (item: any) => Element, trackFieldGetter?: Function, appendUndefinedItems?: boolean): HTMLElement;
/**
    * Replace field value in deep object
    *
    * @param oldVal
    * @param newVal
    * @param {Object} object
    * @returns {{} & Object}
    */
export function deepReplace(oldVal: any, newVal: any, object: any): any;
/**
    * Find value in object by path
    *
    * Example:
    * deepFind({a: {b: 1}}, 'a.b') //1
    *
    * @param {Object} obj
    * @param {string} path
    * @param {boolean} originalIfNotFound
    * @returns {any}
    */
export function deepFind(obj: any, path: string, originalIfNotFound?: boolean): any;
/**
    * Highlight `substr` in `str` by `<mark>` or custom tag
    *
    * @param {string} str
    * @param {string} substr
    * @param {string} tagName. `mark` by default
    * @returns {string} highlighted string
    */
export function highlight(str?: string, substr?: string, tagName?: string): string;
/**
    * Debounce and extract target value from event
    * Useful for shadow-dom case when universal debounce works incorrect
    * @param fn
    * @param timeout
    * @returns {(e) => any}
    */
export function debounceEventValue(fn: Function, timeout: number): (e: Event) => void;
export function getItemsByField(fields: any, items: any[], fieldGetter: Function): any;
export const noopPipe: (item?: any) => any;
export const noop: (item?: any) => void;
/**
    * Cache value for '' query and last value
    */
export class QueryCache {
        get(query?: string): any;
        getLast(): any;
        set(query: string, value: any): void;
        clear(): void;
}

